<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>CRT Canvas — Hue / Kaleidoscope / Pixel Sort + HSL/Palette/Echo/Regen</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0b1118;--panel:#0f1725;--line:#1e293b;--soft:#223145;--ink:#e6eef8;--muted:#9fb3c8;
    --orange:#ffb84d;--blue:#66b3ff;--purple:#b366ff;--green:#66ff99;--red:#ff6666;
  }
  html,body{height:100%}
  body{
    margin:0;display:grid;grid-template-columns:420px 1fr;height:100%;
    background:#000;color:var(--ink);font:13px/1.35 system-ui,Segoe UI,Roboto,Ubuntu;
    overflow:hidden
  }
  aside{background:var(--bg);border-right:1px solid var(--line);overflow:auto;padding:12px}
  canvas{display:block;width:100%;height:100%;background:#000}
  .section{border:1px solid var(--line);border-radius:10px;background:var(--panel);padding:10px;margin:10px 0}
  .section h3{margin:0 0 10px;font:600 12px/1 system-ui;color:var(--muted)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:6px 0}
  .btn{background:#0e1523;border:1px solid var(--soft);color:var(--ink);border-radius:10px;padding:6px 10px;cursor:pointer}
  .btn:hover{border-color:#324155}
  label{display:flex;justify-content:space-between;align-items:center;gap:10px;margin:4px 0}
  input[type=range],input[type=text],input[type=number],select{width:240px}
  input[type=text],input[type=number],select{background:#0b1322;border:1px solid var(--soft);border-radius:10px;color:var(--ink);padding:6px}
  .orange h3{color:var(--orange)} .blue h3{color:var(--blue)} .purple h3{color:var(--purple)} .green h3{color:var(--green)} .red h3{color:var(--red)}
  #log{white-space:pre-wrap;background:#0b0f16;border:1px solid #223;border-radius:8px;padding:8px;color:#9fb3c8}
  .pf aside{display:none}.pf canvas{position:fixed;inset:0;width:100vw;height:100vh}
</style>
</head>
<body>
  <aside id="ui">
    <!-- Source -->
    <div class="section orange">
      <h3>Source</h3>
      <div class="row">
        <button id="btnImg" class="btn">Upload Image</button>
        <button id="btnVid" class="btn">Upload Video</button>
        <button id="btnTP" class="btn">Test Pattern</button>
        <button id="btnSynth" class="btn">Synth</button>
        <input id="fileImg" type="file" accept="image/*" hidden />
        <input id="fileVid" type="file" accept="video/*" hidden />
      </div>
      <div class="row">
        <button id="btnPlay" class="btn">Play</button>
        <button id="btnMute" class="btn">Mute</button>
        <span id="time">00:00 / 00:00</span>
      </div>
      <label>Source Type
        <select id="srcType">
          <option value="image">Image</option>
          <option value="video">Video</option>
          <option value="pattern">Test Pattern</option>
          <option value="synth" selected>Synth</option>
        </select>
      </label>
      <div class="row">
        <label>Fractal <input id="srcFractal" type="checkbox" /></label>
        <label>Plasma <input id="srcPlasma" type="checkbox" checked /></label>
        <label>Voronoi <input id="srcVoro" type="checkbox" /></label>
      </div>
      <label>Source Scale <input id="srcScale" type="range" min="0.5" max="12" step="0.01" value="3" /></label>
      <label>Source Speed <input id="srcSpeed" type="range" min="0" max="4" step="0.001" value="1" /></label>
    </div>

    <!-- Colorizer / Palette -->
    <div class="section purple">
      <h3>Colorizer & Palette</h3>
      <label>Enable Colorizer <input id="czEnable" type="checkbox" checked /></label>
      <label>Palette
        <select id="czPal">
          <option value="warm">Warm Fire</option>
          <option value="cool">Cool Ocean</option>
          <option value="retro" selected>Retro Neon</option>
          <option value="mono">Monochrome</option>
          <option value="custom">Custom (below)</option>
        </select>
      </label>
      <label>Palette Cycle Speed <input id="czSpeed" type="range" min="0" max="2" step="0.001" value="0.2" /></label>
      <label>Colorizer Amount <input id="czAmt" type="range" min="0" max="1" step="0.001" value="1" /></label>
      <div class="row">
        <label>#1 <input id="c1" type="color" value="#ff00ff" style="width:90px"></label>
        <label>#2 <input id="c2" type="color" value="#00ffff" style="width:90px"></label>
        <label>#3 <input id="c3" type="color" value="#ffff00" style="width:90px"></label>
        <label>#4 <input id="c4" type="color" value="#ffffff" style="width:90px"></label>
      </div>
      <div class="row">
        <label>p1 <input id="p1" type="range" min="0" max="1" step="0.001" value="0.0" /></label>
        <label>p2 <input id="p2" type="range" min="0" max="1" step="0.001" value="0.33" /></label>
        <label>p3 <input id="p3" type="range" min="0" max="1" step="0.001" value="0.66" /></label>
        <label>p4 <input id="p4" type="range" min="0" max="1" step="0.001" value="1.0" /></label>
      </div>
    </div>

    <!-- True HSL modulation -->
    <div class="section blue">
      <h3>True HSL Modulation</h3>
      <label>Hue Amount (°) <input id="hslHueAmt" type="range" min="0" max="180" step="0.1" value="60" /></label>
      <label>Sat Amount <input id="hslSatAmt" type="range" min="0" max="1" step="0.001" value="0.4" /></label>
      <label>Light Amount <input id="hslLitAmt" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
      <label>HSL Speed <input id="hslSpeed" type="range" min="0" max="5" step="0.001" value="1.2" /></label>
    </div>

    <!-- Echo / Regen Feedback -->
    <div class="section green">
      <h3>Echo Trails & Regen</h3>
      <label>Echo Amount <input id="echoAmt" type="range" min="0" max="1" step="0.001" value="0.65" /></label>
      <label>Echo Decay <input id="echoDecay" type="range" min="0" max="1" step="0.001" value="0.25" /></label>
      <label>Echo Drift (px) <input id="echoDrift" type="range" min="0" max="20" step="0.1" value="4" /></label>
      <label>Regen Gain <input id="regenGain" type="range" min="0" max="2" step="0.001" value="1.05" /></label>
    </div>

    <!-- Kaleidoscope -->
    <div class="section">
      <h3>Kaleidoscope</h3>
      <label>Segments <input id="kSeg" type="range" min="1" max="12" step="1" value="1" /></label>
      <label>Rotation (°) <input id="kRot" type="range" min="-180" max="180" step="0.1" value="0" /></label>
    </div>

    <!-- Pixel Sorting -->
    <div class="section">
      <h3>Pixel Sorting</h3>
      <label>Length (px) <input id="psLen" type="range" min="0" max="64" step="1" value="0" /></label>
      <label>Threshold <input id="psThr" type="range" min="0" max="1" step="0.001" value="0.5" /></label>
      <label>Mode
        <select id="psMode"><option value="0" selected>Luminance</option><option value="1">Hue</option></select>
      </label>
    </div>

    <!-- CRT / Output -->
    <div class="section red">
      <h3>CRT / Output</h3>
      <label>Mask Preset
        <select id="mask"><option value="0">Triad</option><option value="1">Aperture</option><option value="2">Slot</option><option value="3">Dot</option></select>
      </label>
      <label>Mask Amount <input id="maskAmt" type="range" min="0" max="1" step="0.001" value="0.65" /></label>
      <label>Scanlines <input id="scan" type="range" min="0" max="1" step="0.001" value="0.7" /></label>
      <label>Saturation <input id="sat" type="range" min="0" max="2" step="0.001" value="1.05" /></label>
      <label>Chromatic Ab. <input id="chroma" type="range" min="0" max="1" step="0.001" value="0.3" /></label>
      <label>Noise <input id="noise" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
      <label>Flicker <input id="flick" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
      <label>Global Hue (°) <input id="hue" type="range" min="-180" max="180" step="0.1" value="0" /></label>
    </div>

    <!-- Screen geometry -->
    <div class="section">
      <h3>Screen Geometry</h3>
      <label>Rotation (°) <input id="rot" type="range" min="-180" max="180" step="0.1" value="0" /></label>
      <label>Zoom <input id="zoom" type="range" min="0.85" max="1.5" step="0.001" value="1.0" /></label>
      <label>Aspect Ratio <input id="ratio" type="text" placeholder="4:3" /></label>
      <div class="row">
        <button id="btnFS" class="btn">Fullscreen (F)</button>
      </div>
    </div>

    <!-- Self-tests -->
    <div class="section">
      <h3>Self-tests</h3>
      <pre id="log">(running…) 
</pre>
    </div>
  </aside>

  <canvas id="gl"></canvas>

<script>
(function(){
'use strict';
const $=id=>document.getElementById(id);
const CAN=$('gl');
let W=innerWidth-420, H=innerHeight; CAN.width=W; CAN.height=H;

const TL=$('log');
const log=(s,ok)=>{TL.textContent+=(ok===undefined?'':(ok?'✔ ':'✖ '))+s+'\\n'};

// ---------- Source buffers ----------
const SRC_CAN=document.createElement('canvas'), SRC_CTX=SRC_CAN.getContext('2d');
SRC_CAN.width=960; SRC_CAN.height=540;
let bmp=null;
const VID=document.createElement('video'); VID.playsInline=true; VID.loop=true; VID.muted=true; VID.preload='metadata';
let sourceMode='synth';

$('btnImg').onclick=()=>$('fileImg').click();
$('btnVid').onclick=()=>$('fileVid').click();
$('btnTP').onclick=()=>{ sourceMode='pattern'; $('srcType').value='pattern' };
$('btnSynth').onclick=()=>{ sourceMode='synth'; $('srcType').value='synth' };
$('srcType').onchange=e=>{ sourceMode=e.target.value };

$('fileImg').addEventListener('change',async e=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{ bmp=await createImageBitmap(f); sourceMode='image'; $('srcType').value='image';
    SRC_CAN.width=bmp.width; SRC_CAN.height=bmp.height;
  }catch(err){log('image load '+err,false)}
});
$('fileVid').addEventListener('change',async e=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{ sourceMode='video'; $('srcType').value='video'; VID.src=URL.createObjectURL(f); await VID.play().catch(()=>{});
    $('btnPlay').textContent='Pause';
  }catch(err){log('video load '+err,false)}
});
$('btnPlay').onclick=async()=>{
  if(sourceMode!=='video') return;
  if(VID.paused){ await VID.play().catch(()=>{}); $('btnPlay').textContent='Pause'; }
  else { VID.pause(); $('btnPlay').textContent='Play'; }
};
$('btnMute').onclick=()=>{ if(sourceMode!=='video') return; VID.muted=!VID.muted; $('btnMute').textContent=VID.muted?'Unmute':'Mute' };
const fmt=s=>{s=Math.max(0,s|0);const m=(s/60)|0,r=s%60;return String(m).padStart(2,'0')+':'+String(r).padStart(2,'0')};
VID.addEventListener('timeupdate',()=>{ $('time').textContent = isFinite(VID.duration)? (fmt(VID.currentTime)+' / '+fmt(VID.duration)) : '00:00 / 00:00' });

// Test pattern
function drawPattern(t){
  const w=SRC_CAN.width,h=SRC_CAN.height;
  SRC_CTX.fillStyle='#121620'; SRC_CTX.fillRect(0,0,w,h);
  const bars=['#fff','#ff0','#0ff','#0f0','#f0f','#00f','#f00'], bw=(w/bars.length)|0;
  for(let i=0;i<bars.length;i++){ SRC_CTX.fillStyle=bars[i]; SRC_CTX.fillRect(i*bw,0,bw-1,(h*0.35)|0); }
  SRC_CTX.strokeStyle='rgba(255,255,255,0.12)'; for(let x=0;x<w;x+= (w/24)|0 ){ SRC_CTX.beginPath(); SRC_CTX.moveTo(x,0); SRC_CTX.lineTo(x,h); SRC_CTX.stroke(); }
  SRC_CTX.fillStyle='#fff'; SRC_CTX.font=(h*0.08|0)+'px ui-monospace,Menlo'; SRC_CTX.fillText('TEST PATTERN',18,h-22);
}

// ---------- WebGL ----------
const gl=CAN.getContext('webgl',{alpha:false,antialias:false,preserveDrawingBuffer:false});
if(!gl){TL.textContent+='WebGL not supported';return}

function makeTex(w,h){
  const t=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,t);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
  return t;
}

// ping-pong prev frame
let prevA=makeTex(CAN.width,CAN.height), prevB=makeTex(CAN.width,CAN.height), useA=true;
const fb=gl.createFramebuffer();
function resizePrev(w,h){
  [prevA,prevB].forEach(t=>gl.deleteTexture(t));
  prevA=makeTex(w,h); prevB=makeTex(w,h);
  gl.bindFramebuffer(gl.FRAMEBUFFER,fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,prevA,0);
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,prevB,0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER,null);
}

const VERT=`
attribute vec2 a;varying vec2 v;
void main(){v=(a+1.0)*0.5;gl_Position=vec4(a,0.,1.);}
`;
const FRAG=`
precision mediump float;varying vec2 v;
uniform vec2  u_res;uniform float u_time;
uniform sampler2D u_src;     // uploaded / generated source
uniform sampler2D u_prev;    // previous frame (echo/regen)
uniform vec4  u_srcFx;       // x:fractal y:plasma z:voronoi w:amount
uniform float u_srcScale,u_srcSpeed;

// Colorizer / Palette
uniform int   u_czEnable;
uniform vec3  u_czC1,u_czC2,u_czC3,u_czC4;
uniform float u_czP1,u_czP2,u_czP3,u_czP4;
uniform float u_czSpeed,u_czAmt;

// HSL modulation
uniform float u_hslHueAmt,u_hslSatAmt,u_hslLitAmt,u_hslSpeed;

// Echo / Regen
uniform float u_echoAmt,u_echoDecay,u_echoDrift,u_regenGain;

// Kaleidoscope
uniform float u_kSeg,u_kRot;

// Pixel Sort
uniform float u_psLen,u_psThr; uniform int u_psMode;

// CRT / Output
uniform int   u_maskType;
uniform float u_maskAmt,u_scan,u_sat,u_ca,u_noise,u_flick,u_hue,u_rot,u_zoom,u_ratio;

// --- helpers ---
float H(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float N(vec2 p){vec2 i=floor(p),f=fract(p);float a=H(i),b=H(i+vec2(1.,0.)),c=H(i+vec2(0.,1.)),d=H(i+vec2(1.,1.));vec2 u=f*f*(3.-2.*f);
return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}
float fbm(vec2 p){float n=0.,a=1.;for(int i=0;i<5;i++){n+=N(p*a)/a;a*=2.;}return n;}
vec2 crop(vec2 uv){if(u_ratio<=0.)return uv;float outR=u_res.x/u_res.y,t=u_ratio;vec2 c=uv-0.5;if(outR>t)c.x*=outR/t;else c.y*=t/outR;return c+0.5;}
vec2 rot2(vec2 uv,float a){vec2 p=uv-0.5;float s=sin(a),c=cos(a);return mat2(c,-s,s,c)*p+0.5;}
float lum(vec3 c){return dot(c,vec3(0.2126,0.7152,0.0722));}
vec3 plasma(vec2 uv){return 0.5+0.5*cos(u_time+uv.xyx*vec3(1,1.3,1.7));}
vec3 voro(vec2 uv){vec2 g=floor(uv),f=fract(uv);float md=1.;for(int y=-1;y<=1;y++)for(int x=-1;x<=1;x++){vec2 o=vec2(float(x),float(y));vec2 rp=g+o+H(g+o);float d=length(f-o-rp);md=min(md,d);}return vec3(md);}
vec2 kalei(vec2 uv,float seg,float deg){ if(seg<=1.0) return uv; vec2 p=uv-0.5; float r=length(p); float a=atan(p.y,p.x)+radians(deg); float s=6.2831853/seg; float aa=mod(a,s); aa=min(aa,s-aa); vec2 q=vec2(cos(aa),sin(aa))*r; return q+0.5; }

// Shadow mask
vec3 maskFX(vec2 uv,int m,float k){
  vec3 tri; float x = fract(uv.x*u_res.x/3.0);
  tri = x<1.0/3.0? vec3(1.0,0.7,0.7) : (x<2.0/3.0? vec3(0.7,1.0,0.7): vec3(0.7,0.7,1.0));
  if(m==1){ float s=fract(uv.x*2.0); tri = mix(vec3(1.0), vec3(1.0,1.0,0.8), step(0.5,s)); }
  else if(m==2){ float s=fract(uv.x*2.0); tri = mix(vec3(1.0), vec3(0.9,1.0,0.9), step(0.5,s)); }
  else if(m==3){ tri = vec3(1.0); }
  return mix(vec3(1.0), tri, clamp(k,0.0,1.0));
}

// Hue rotation matrix (sRGB approx)
mat3 hueM(float a){
  float U=cos(a),W=sin(a);
  mat3 m=mat3(0.299,0.587,0.114, 0.299,0.587,0.114, 0.299,0.587,0.114);
  mat3 r=mat3(0.701,-0.587,-0.114, -0.299,0.413,-0.114, -0.300,-0.588,0.886);
  return m+r*U+mat3(0.168,0.330,-0.497, -0.328,0.035,0.292, 1.25,-1.05,-0.203)*W;
}

// RGB <-> HSL
vec3 rgb2hsl(vec3 c){
  float mx=max(max(c.r,c.g),c.b);
  float mn=min(min(c.r,c.g),c.b);
  float h=0.0,s=0.0,l=(mx+mn)*0.5;
  float d=mx-mn;
  if(d>1e-6){
    s = l>0.5 ? d/(2.0-mx-mn) : d/(mx+mn);
    if(mx==c.r) h=(c.g-c.b)/d + (c.g<c.b?6.0:0.0);
    else if(mx==c.g) h=(c.b-c.r)/d + 2.0;
    else h=(c.r-c.g)/d + 4.0;
    h/=6.0;
  }
  return vec3(h,s,l);
}
float hue2rgb(float p,float q,float t){
  if(t<0.0)t+=1.0; if(t>1.0)t-=1.0;
  if(t<1.0/6.0) return p + (q-p)*6.0*t;
  if(t<1.0/2.0) return q;
  if(t<2.0/3.0) return p + (q-p)*(2.0/3.0 - t)*6.0;
  return p;
}
vec3 hsl2rgb(vec3 hsl){
  float h=hsl.x,s=hsl.y,l=hsl.z;
  float r,g,b;
  if(s<=0.0){r=g=b=l;}
  else{
    float q = l<0.5 ? l*(1.0+s) : l + s - l*s;
    float p = 2.0*l - q;
    r=hue2rgb(p,q,h+1.0/3.0);
    g=hue2rgb(p,q,h);
    b=hue2rgb(p,q,h-1.0/3.0);
  }
  return vec3(r,g,b);
}

// Color ramp (4 stops), with cycle phase
vec3 ramp(float x, vec3 c1,vec3 c2,vec3 c3,vec3 c4, float p1,float p2,float p3,float p4, float phase){
  x = fract(x + phase);
  p1=clamp(p1,0.0,1.0); p2=clamp(p2,0.0,1.0); p3=clamp(p3,0.0,1.0); p4=clamp(p4,0.0,1.0);
  if(x<=p2){ float t=smoothstep(p1,p2,x); return mix(c1,c2,t); }
  else if(x<=p3){ float t=smoothstep(p2,p3,x); return mix(c2,c3,t); }
  else { float t=smoothstep(p3,p4,x); return mix(c3,c4,t); }
}

// Pixel sort (horizontal, simple best-of-window)
vec3 pixelSort(vec2 uv, vec3 base){
  float Lref = (u_psMode==1)? atan(base.g*1.732, base.b - base.r) : lum(base);
  vec3 best = base; float bestM = Lref;
  for(int i=1;i<=64;i++){
    if(float(i)>u_psLen) break;
    vec2 uv2 = uv + vec2(float(i)/u_res.x, 0.0);
    uv2 = clamp(uv2, vec2(0.0), vec2(1.0));
    vec3 c2 = texture2D(u_src, uv2).rgb;
    float m2 = (u_psMode==1)? atan(c2.g*1.732, c2.b - c2.r) : lum(c2);
    if(m2>bestM && m2>u_psThr){ best=c2; bestM=m2; }
  }
  return best;
}

void main(){
  vec2 uv=crop(v);
  uv=kalei(uv, u_kSeg, u_kRot);
  uv=rot2(uv,radians(u_rot));
  uv=(uv-0.5)/max(u_zoom,0.0001)+0.5;
  if(any(lessThan(uv,vec2(0.)))||any(greaterThan(uv,vec2(1.)))){gl_FragColor=vec4(0,0,0,1);return;}

  // base from source
  vec3 base=texture2D(u_src,uv).rgb;

  // procedurals for synth/source mix
  vec3 proc=vec3(0.0); float cnt=0.0;
  if(u_srcFx.x>0.5){ proc += vec3(fbm((uv-0.5)*u_srcScale + u_time*0.15*u_srcSpeed)); cnt+=1.0; }
  if(u_srcFx.y>0.5){ proc += plasma(uv*u_srcScale); cnt+=1.0; }
  if(u_srcFx.z>0.5){ proc += voro(uv*u_srcScale*2.0); cnt+=1.0; }
  if(cnt>0.0) proc/=cnt;
  vec3 col=mix(base,proc,u_srcFx.w);

  // Pixel sort over source (use current base)
  if(u_psLen>0.5){
    vec3 ps = pixelSort(uv, col);
    col = ps;
  }

  // echo / regen (prev frame)
  vec2 drift=vec2(u_echoDrift/u_res.x, u_echoDrift/u_res.y);
  vec3 prev = texture2D(u_prev, uv+drift).rgb;
  prev *= (1.0 - u_echoDecay);
  col = mix(col, prev, clamp(u_echoAmt,0.0,1.0));
  col *= max(u_regenGain,0.0);
  col = clamp(col,0.0,1.0);

  // colorizer ramp
  if(u_czEnable==1){
    float L = lum(col);
    vec3 rc = ramp(L, u_czC1,u_czC2,u_czC3,u_czC4, u_czP1,u_czP2,u_czP3,u_czP4, u_czSpeed*u_time);
    col = mix(col, rc, clamp(u_czAmt,0.0,1.0));
  }

  // HSL modulation
  float ph=u_time*u_hslSpeed;
  float dH = (u_hslHueAmt/360.0)*sin(ph);
  float dS = u_hslSatAmt*sin(ph*1.3);
  float dL = u_hslLitAmt*sin(ph*0.8);
  vec3 hsl=rgb2hsl(col);
  hsl.x=fract(hsl.x+dH);
  hsl.y=clamp(hsl.y+dS,0.0,1.0);
  hsl.z=clamp(hsl.z+dL,0.0,1.0);
  col=hsl2rgb(hsl);

  // chromatic aberration (from source tex)
  vec2 dir=(uv-0.5); float ca=u_ca*0.0035; vec2 off=ca*normalize(dir+1e-5);
  vec3 caCol=vec3(texture2D(u_src,uv+off).r, col.g, texture2D(u_src,uv-off).b);
  col=mix(col,caCol,clamp(u_ca,0.0,1.0));

  // scanlines
  float sc=sin(uv.y*u_res.y*3.14159);
  col*=mix(1.0, 0.6+0.4*sc, clamp(u_scan,0.0,1.0));

  // shadow mask
  col*=maskFX(uv,u_maskType,u_maskAmt);

  // saturation + global hue rotate
  float L2=lum(col);
  col=mix(vec3(L2),col,clamp(u_sat,0.0,2.0));
  col=clamp(hueM(radians(u_hue))*col,0.0,1.0);

  // noise + flicker
  float n=H(floor(uv*u_res)+u_time);
  col *= 1.0 + (u_flick*(sin(u_time*120.0)*0.03));
  col += (n-0.5)*0.12*u_noise;

  gl_FragColor=vec4(clamp(col,0.0,1.0),1.0);
}
`;
function sh(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);return s}
const prog=gl.createProgram();gl.attachShader(prog,sh(gl.VERTEX_SHADER,VERT));gl.attachShader(prog,sh(gl.FRAGMENT_SHADER,FRAG));gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS))throw gl.getProgramInfoLog(prog);
gl.useProgram(prog);

// quad
const vbo=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
const a=gl.getAttribLocation(prog,'a');gl.enableVertexAttribArray(a);gl.vertexAttribPointer(a,2,gl.FLOAT,false,0,0);

// uniforms/tex
const U=n=>gl.getUniformLocation(prog,n),u={
  res:U('u_res'), time:U('u_time'), src:U('u_src'), prev:U('u_prev'),
  srcFx:U('u_srcFx'), srcScale:U('u_srcScale'), srcSpeed:U('u_srcSpeed'),
  czEnable:U('u_czEnable'), czC1:U('u_czC1'), czC2:U('u_czC2'), czC3:U('u_czC3'), czC4:U('u_czC4'),
  czP1:U('u_czP1'), czP2:U('u_czP2'), czP3:U('u_czP3'), czP4:U('u_czP4'),
  czSpeed:U('u_czSpeed'), czAmt:U('u_czAmt'),
  hslHueAmt:U('u_hslHueAmt'), hslSatAmt:U('u_hslSatAmt'), hslLitAmt:U('u_hslLitAmt'), hslSpeed:U('u_hslSpeed'),
  echoAmt:U('u_echoAmt'), echoDecay:U('u_echoDecay'), echoDrift:U('u_echoDrift'), regenGain:U('u_regenGain'),
  kSeg:U('u_kSeg'), kRot:U('u_kRot'),
  psLen:U('u_psLen'), psThr:U('u_psThr'), psMode:U('u_psMode'),
  maskType:U('u_maskType'), maskAmt:U('u_maskAmt'), scan:U('u_scan'), sat:U('u_sat'), ca:U('u_ca'),
  noise:U('u_noise'), flick:U('u_flick'), hue:U('u_hue'), rot:U('u_rot'), zoom:U('u_zoom'), ratio:U('u_ratio')
};
const texSrc=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texSrc);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
gl.uniform1i(u.src,0); // TEXTURE0
gl.uniform1i(u.prev,1); // TEXTURE1

function updateSourceCanvas(t){
  if(sourceMode==='pattern'){ drawPattern(t); }
  else if(sourceMode==='image'&&bmp){ if(SRC_CAN.width!==bmp.width||SRC_CAN.height!==bmp.height){SRC_CAN.width=bmp.width;SRC_CAN.height=bmp.height} SRC_CTX.drawImage(bmp,0,0,SRC_CAN.width,SRC_CAN.height); }
  else if(sourceMode==='video'&&VID.readyState>=2){ const vw=VID.videoWidth||640, vh=VID.videoHeight||360; if(SRC_CAN.width!==vw||SRC_CAN.height!==vh){SRC_CAN.width=vw;SRC_CAN.height=vh} SRC_CTX.drawImage(VID,0,0,SRC_CAN.width,SRC_CAN.height); }
  else if(sourceMode==='synth'){ SRC_CTX.clearRect(0,0,SRC_CAN.width,SRC_CAN.height); }
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D,texSrc);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,SRC_CAN);
}

// fullscreen (policy-safe fallback)
function tryFS(){return new Promise((res,rej)=>{const el=CAN;const req=el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen;if(!req)return rej('no api');try{const p=req.call(el);if(p&&p.then)p.then(()=>res(true)).catch(rej);else res(true)}catch(e){rej(e)}})}
$('btnFS').onclick=()=>{ if(!document.fullscreenElement){tryFS().catch(()=>{document.body.classList.add('pf')})} else {(document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen)?.call(document);document.body.classList.remove('pf')} };
document.addEventListener('keydown',e=>{ if(e.key==='f'||e.key==='F')$('btnFS').click(); });

// resize
addEventListener('resize',()=>{
  W=innerWidth-420; H=innerHeight; CAN.width=W; CAN.height=H;
  gl.viewport(0,0,W,H);
  resizePrev(W,H);
});

// palette presets
function hex3(s){const r=parseInt(s.slice(1,3),16)/255,g=parseInt(s.slice(3,5),16)/255,b=parseInt(s.slice(5,7),16)/255;return [r,g,b];}
function applyPalettePreset(){
  const p=$('czPal').value;
  if(p==='warm'){ $('c1').value='#1b0f05'; $('c2').value='#ff5a00'; $('c3').value='#ffd700'; $('c4').value='#fff4d6'; }
  if(p==='cool'){ $('c1').value='#041a2f'; $('c2').value='#0aa1ff'; $('c3').value='#7ef9ff'; $('c4').value='#e0ffff'; }
  if(p==='retro'){ $('c1').value='#1a0033'; $('c2').value='#ff00ff'; $('c3').value='#00ffff'; $('c4').value='#ffffcc'; }
  if(p==='mono'){ $('c1').value='#000000'; $('c2').value='#555555'; $('c3').value='#aaaaaa'; $('c4').value='#ffffff'; }
}
$('czPal').addEventListener('change',()=>{ if($('czPal').value!=='custom') applyPalettePreset(); });

// self tests
(function(){
  const ids=['btnImg','btnVid','btnTP','btnSynth','srcType','srcFractal','srcPlasma','srcVoro','srcScale','srcSpeed','czEnable','czPal','czSpeed','czAmt','c1','c2','c3','c4','p1','p2','p3','p4','hslHueAmt','hslSatAmt','hslLitAmt','hslSpeed','echoAmt','echoDecay','echoDrift','regenGain','kSeg','kRot','psLen','psThr','psMode','mask','maskAmt','scan','sat','chroma','noise','flick','hue','rot','zoom','ratio','btnFS'];
  log('UI elements present: '+ids.every(id=>!!$(id)));
  // aspect ratio parser quick checks
  const r=$('ratio'), cases=[['4:3',4/3],['16:9',16/9],['1.25',1.25],['1,25',1.25],[' 21 : 9 ',21/9],['9:16',9/16]];
  let ok=true; for(const [i,e] of cases){ r.value=i; const v=(()=>{let s=(r.value||'').trim();if(!s)return 0;if(s.includes(':')){const[a,b]=s.split(':').map(x=>parseFloat(x.replace(',','.')));return(isFinite(a)&&isFinite(b)&&b!==0)?a/b:0}const f=parseFloat(s.replace(',','.'));return(isFinite(f)&&f>0)?f:0})(); ok=ok&&Math.abs(v-e)<1e-6; }
  r.value=''; log('aspect ratio parser',ok);
})();

// draw loop
function frame(ts){
  const t=ts*0.001;

  updateSourceCanvas(t);

  gl.viewport(0,0,CAN.width,CAN.height);
  gl.uniform2f(u.res,CAN.width,CAN.height);
  gl.uniform1f(u.time,t);

  // source fx toggles/params
  const fxX=$('srcFractal').checked?1:0, fxY=$('srcPlasma').checked?1:0, fxZ=$('srcVoro').checked?1:0;
  const isSynth = $('srcType').value==='synth';
  gl.uniform4f(u.srcFx,fxX,fxY,fxZ, isSynth?1.0:0.0);
  gl.uniform1f(u.srcScale,parseFloat($('srcScale').value||3));
  gl.uniform1f(u.srcSpeed,parseFloat($('srcSpeed').value||1));

  // colorizer uniforms
  gl.uniform1i(u.czEnable, $('czEnable').checked?1:0);
  const [c1r,c1g,c1b]=hex3($('c1').value), [c2r,c2g,c2b]=hex3($('c2').value), [c3r,c3g,c3b]=hex3($('c3').value), [c4r,c4g,c4b]=hex3($('c4').value);
  gl.uniform3f(u.czC1,c1r,c1g,c1b); gl.uniform3f(u.czC2,c2r,c2g,c2b); gl.uniform3f(u.czC3,c3r,c3g,c3b); gl.uniform3f(u.czC4,c4r,c4g,c4b);
  gl.uniform1f(u.czP1,parseFloat($('p1').value||0)); gl.uniform1f(u.czP2,parseFloat($('p2').value||0.33));
  gl.uniform1f(u.czP3,parseFloat($('p3').value||0.66)); gl.uniform1f(u.czP4,parseFloat($('p4').value||1));
  gl.uniform1f(u.czSpeed,parseFloat($('czSpeed').value||0.2));
  gl.uniform1f(u.czAmt,parseFloat($('czAmt').value||1));

  // HSL modulation
  gl.uniform1f(u.hslHueAmt,parseFloat($('hslHueAmt').value||0));
  gl.uniform1f(u.hslSatAmt,parseFloat($('hslSatAmt').value||0));
  gl.uniform1f(u.hslLitAmt,parseFloat($('hslLitAmt').value||0));
  gl.uniform1f(u.hslSpeed,parseFloat($('hslSpeed').value||1));

  // Echo/Regen
  gl.uniform1f(u.echoAmt,parseFloat($('echoAmt').value||0));
  gl.uniform1f(u.echoDecay,parseFloat($('echoDecay').value||0));
  gl.uniform1f(u.echoDrift,parseFloat($('echoDrift').value||0));
  gl.uniform1f(u.regenGain,parseFloat($('regenGain').value||1));

  // Kaleidoscope
  gl.uniform1f(u.kSeg,parseFloat($('kSeg').value||1));
  gl.uniform1f(u.kRot,parseFloat($('kRot').value||0));

  // Pixel sort
  gl.uniform1f(u.psLen,parseFloat($('psLen').value||0));
  gl.uniform1f(u.psThr,parseFloat($('psThr').value||0.5));
  gl.uniform1i(u.psMode,parseInt($('psMode').value||'0'));

  // CRT/out
  gl.uniform1i(u.maskType,parseInt($('mask').value||'0'));
  gl.uniform1f(u.maskAmt,parseFloat($('maskAmt').value||0.65));
  gl.uniform1f(u.scan,parseFloat($('scan').value||0.7));
  gl.uniform1f(u.sat,parseFloat($('sat').value||1.0));
  gl.uniform1f(u.ca,parseFloat($('chroma').value||0.15));
  gl.uniform1f(u.noise,parseFloat($('noise').value||0.2));
  gl.uniform1f(u.flick,parseFloat($('flick').value||0.2));
  gl.uniform1f(u.hue,parseFloat($('hue').value||0)); // global hue knob (°)
  gl.uniform1f(u.rot,parseFloat($('rot').value||0));
  gl.uniform1f(u.zoom,parseFloat($('zoom').value||1));
  // aspect ratio parse
  const rv=(()=>{let s=($('ratio').value||'').trim();if(!s)return 0;if(s.includes(':')){const[a,b]=s.split(':').map(x=>parseFloat(x.replace(',','.')));return(isFinite(a)&&isFinite(b)&&b!==0)?a/b:0}const f=parseFloat(s.replace(',','.'));return(isFinite(f)&&f>0)?f:0})();
  gl.uniform1f(u.ratio,rv);

  // bind textures
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D,texSrc);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, useA?prevA:prevB);

  // draw
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

  // copy current framebuffer to next prev texture
  gl.activeTexture(gl.TEXTURE1);
  const target = useA?prevB:prevA;
  gl.bindTexture(gl.TEXTURE_2D,target);
  gl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGBA,0,0,CAN.width,CAN.height,0);
  useA=!useA;

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// fullscreen (policy-safe fallback)
function tryFS(){return new Promise((res,rej)=>{const el=CAN;const req=el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen;if(!req)return rej('no api');try{const p=req.call(el);if(p&&p.then)p.then(()=>res(true)).catch(rej);else res(true)}catch(e){rej(e)}})}
$('btnFS').onclick=()=>{ if(!document.fullscreenElement){tryFS().catch(()=>{document.body.classList.add('pf')})} else {(document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen)?.call(document);document.body.classList.remove('pf')} };
document.addEventListener('keydown',e=>{ if(e.key==='f'||e.key==='F')$('btnFS').click(); });

// resize
addEventListener('resize',()=>{
  W=innerWidth-420; H=innerHeight; CAN.width=W; CAN.height=H;
  gl.viewport(0,0,W,H);
  resizePrev(W,H);
});

// palette preset on load
function applyPalettePreset(){
  const p=$('czPal').value;
  if(p==='warm'){ $('c1').value='#1b0f05'; $('c2').value='#ff5a00'; $('c3').value='#ffd700'; $('c4').value='#fff4d6'; }
  if(p==='cool'){ $('c1').value='#041a2f'; $('c2').value='#0aa1ff'; $('c3').value='#7ef9ff'; $('c4').value='#e0ffff'; }
  if(p==='retro'){ $('c1').value='#1a0033'; $('c2').value='#ff00ff'; $('c3').value='#00ffff'; $('c4').value='#ffffcc'; }
  if(p==='mono'){ $('c1').value='#000000'; $('c2').value='#555555'; $('c3').value='#aaaaaa'; $('c4').value='#ffffff'; }
}
applyPalettePreset();

})();
</script>
</body>
</html>
