<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>WEBGL CRT — Full UI (Merged)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0b1118;--bg2:#0e1523;--panel:#101826;--card:#0f1522;--soft:#1c2740;
    --ink:#e6eef8;--muted:#9fb3c8;--accent:#ff4d4d;--line:#1e293b;
    --orange:#ffb84d;--blue:#66b3ff;--purple:#b366ff;--green:#66ff99;--red:#ff6666;--gray:#ccc;
  }
  html,body{height:100%}
  body{
    margin:0;display:grid;grid-template-columns:420px 1fr;height:100%;
    background:#000;color:var(--ink);font:13px/1.35 system-ui,Segoe UI,Roboto,Ubuntu;
    overflow:hidden;
  }
  aside{background:var(--bg);border-right:1px solid var(--line);overflow:auto;padding:12px}
  canvas{display:block;width:100%;height:100%;background:#000}
  .section{border:1px solid var(--line);border-radius:10px;background:var(--panel);padding:10px;margin:10px 0}
  .section h3{margin:0 0 10px;font:600 12px/1 system-ui;color:var(--muted)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:6px 0}
  .btn{
    background:var(--bg2);border:1px solid var(--soft);color:var(--ink);
    border-radius:10px;padding:6px 10px;cursor:pointer;user-select:none
  }
  .btn:hover{border-color:#324155}
  label{display:flex;justify-content:space-between;align-items:center;gap:10px;margin:4px 0}
  input[type=range],input[type=text],input[type=number],select{width:240px}
  input[type=text],input[type=number],select{
    background:var(--card);border:1px solid var(--soft);border-radius:10px;color:var(--ink);padding:6px
  }
  .pill{font-size:11px;color:#94a9c4;border:1px solid var(--soft);border-radius:999px;padding:4px 8px;display:inline-block;margin-bottom:6px}
  .small{font-size:12px;color:#9fb3c8}
  .orange h3{color:var(--orange)} .blue h3{color:var(--blue)} .purple h3{color:var(--purple)}
  .green h3{color:var(--green)} .red h3{color:var(--red)} .gray h3{color:var(--gray)}
  #log{white-space:pre-wrap;background:#0b0f16;border:1px solid #223;border-radius:8px;padding:8px;color:#9fb3c8}
  /* fullscreen fallback (policy-safe) */
  .pf aside{display:none}
  .pf canvas{position:fixed;inset:0;width:100vw;height:100vh}
</style>
</head>
<body>
  <aside id="ui">
    <div class="pill">WEBGL CRT</div>

    <!-- Source -->
    <div class="section orange">
      <h3>Source</h3>
      <div class="row">
        <button id="btnImg" class="btn">Upload Image</button>
        <button id="btnVid" class="btn">Upload Video</button>
        <button id="btnTP"  class="btn">Use Test Pattern</button>
        <button id="btnSynth" class="btn">Use Synth</button>
        <input id="fileImg" type="file" accept="image/*" hidden />
        <input id="fileVid" type="file" accept="video/*" hidden />
      </div>
      <div class="row">
        <button id="btnPlay" class="btn">Play</button>
        <button id="btnMute" class="btn">Mute</button>
        <span id="time">00:00 / 00:00</span>
      </div>
    </div>

    <!-- Presets -->
    <div class="section">
      <h3>Presets</h3>
      <div class="row">
        <select id="preset">
          <option value="">— choose —</option>
          <option>Kaleido Drift</option>
          <option>Minimal CRT</option>
          <option>Liquid Plasma</option>
          <option>Cellular Drift</option>
          <option>Pixel Glow</option>
          <option>Retro Arcade</option>
          <option>Calm Geometry</option>
          <option>Ghost Trails</option>
        </select>
        <button id="btnLoad" class="btn">Load</button>
        <button id="btnRand" class="btn">Randomize</button>
      </div>
      <div class="row">
        <button id="btnSnap" class="btn">Save Snapshot</button>
      </div>
      <div class="row">
        <label>Live Cycle <input id="live" type="checkbox" /></label>
        <label>Time (s) <input id="liveSecs" type="number" min="3" max="120" value="20" /></label>
        <label>Blend <select id="liveBlend"><option value="cut">Cut</option><option value="blend">Blend</option></select></label>
      </div>
    </div>

    <!-- Audio reactive -->
    <div class="section gray">
      <h3>Audio-Reactive</h3>
      <label>Source
        <select id="audSrc"><option value="off">Off</option><option value="mic">Microphone</option><option value="video">Video Audio</option></select>
      </label>
      <div class="row">
        <button id="btnMic" class="btn">Enable Mic</button>
        <span class="small">low:<span id="vL">0</span> mid:<span id="vM">0</span> hi:<span id="vH">0</span></span>
      </div>
    </div>

    <!-- Synth -->
    <div class="section blue">
      <h3>Synth (Lumen/Cathodemer-style)</h3>
      <label>Hue Shift <input id="synHue" type="range" min="0" max="1" step="0.001" value="0.33" /></label>
      <label>Hue Intensity <input id="synHueD" type="range" min="0" max="1.5" step="0.001" value="0.6" /></label>
      <label>Key Threshold <input id="synKey" type="range" min="0" max="1" step="0.001" value="0.15" /></label>
      <label>Key Softness <input id="synSoft" type="range" min="0" max="0.5" step="0.001" value="0.08" /></label>
      <label>Rotate Speed (°/s) <input id="synRotSpd" type="range" min="-90" max="90" step="0.1" value="0" /></label>

      <div class="row"><strong>Osc A</strong></div>
      <label>Wave A
        <select id="waveA"><option>Sine</option><option>Square</option><option>Triangle</option><option>Saw</option><option>Trapezoid</option></select>
      </label>
      <label>Freq A (cyc) <input id="freqA" type="range" min="0" max="20" step="0.01" value="2.0" /></label>
      <label>Angle A (°) <input id="angA" type="range" min="-180" max="180" step="0.1" value="0" /></label>

      <div class="row"><strong>Osc B</strong></div>
      <label>Wave B
        <select id="waveB"><option>Sine</option><option>Square</option><option>Triangle</option><option>Saw</option><option>Trapezoid</option></select>
      </label>
      <label>Freq B (cyc) <input id="freqB" type="range" min="0" max="20" step="0.01" value="3.5" /></label>
      <label>Angle B (°) <input id="angB" type="range" min="-180" max="180" step="0.1" value="45" /></label>

      <div class="row"><strong>Osc C</strong></div>
      <label>Wave C
        <select id="waveC"><option>Sine</option><option>Square</option><option>Triangle</option><option>Saw</option><option>Trapezoid</option></select>
      </label>
      <label>Freq C (cyc) <input id="freqC" type="range" min="0" max="20" step="0.01" value="1.0" /></label>
      <label>Angle C (°) <input id="angC" type="range" min="-180" max="180" step="0.1" value="120" /></label>

      <div class="row"><strong>Shape</strong></div>
      <label>Circle Amount <input id="shapeAmt" type="range" min="0" max="1" step="0.001" value="0.0" /></label>
      <label>Circle Size <input id="shapeSize" type="range" min="0" max="1" step="0.001" value="0.5" /></label>
      <label>Circle Softness <input id="shapeSoft" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
    </div>

    <!-- Synth <-> Source -->
    <div class="section">
      <h3>Synth ⇄ Source Interaction</h3>
      <label>Mode
        <select id="sxMode">
          <option>Displace + Key</option>
          <option>Key Only</option>
          <option>Displace Only</option>
        </select>
      </label>
      <label>Amount <input id="sxAmt" type="range" min="0" max="1" step="0.001" value="0.8" /></label>
      <label>Displace (px) <input id="sxDisp" type="range" min="0" max="40" step="0.1" value="12" /></label>
    </div>

    <!-- Effects -->
    <div class="section purple">
      <h3>Effects (stack)</h3>
      <label>Fractal <input id="fxFractal" type="checkbox" /></label>
      <label>Plasma <input id="fxPlasma" type="checkbox" checked /></label>
      <label>Voronoi <input id="fxVoro" type="checkbox" /></label>
      <label>Pixel Sort <input id="fxSort" type="checkbox" /></label>
      <label>Sort Mode
        <select id="sortMode"><option value="lum">Luminance</option><option value="hue">Hue</option></select>
      </label>
      <label>Fractal Type
        <select id="fracType"><option value="perlin">Perlin</option><option value="simplex">Simplex</option></select>
      </label>
      <label>Effect Scale <input id="fxScale" type="range" min="0.5" max="12" step="0.01" value="3" /></label>
      <label>Effect Speed <input id="fxSpeed" type="range" min="0" max="4" step="0.001" value="1" /></label>
      <label>Effect Amount <input id="fxAmt" type="range" min="0" max="1" step="0.001" value="1" /></label>
    </div>

    <!-- Feedback -->
    <div class="section">
      <h3>Feedback (Pre-CRT)</h3>
      <label>Amount <input id="fbAmt" type="range" min="0" max="1" step="0.001" value="0.6" /></label>
      <label>Blur (px) <input id="fbBlur" type="range" min="0" max="8" step="0.1" value="1.0" /></label>
      <label>Drift (px) <input id="fbDrift" type="range" min="0" max="20" step="0.1" value="6" /></label>
      <label>Taps (1–3)
        <select id="fbTaps"><option>1</option><option>2</option><option selected>3</option></select>
      </label>
      <label>Tap Decay <input id="fbDecay" type="range" min="0" max="1" step="0.001" value="0.6" /></label>
    </div>

    <!-- Recording -->
    <div class="section">
      <h3>Recording</h3>
      <label>Duration (s) <input id="recSecs" type="number" min="1" max="60" value="5" /></label>
      <div class="row">
        <button id="btnRec" class="btn">Start Recording</button>
        <button id="btnStop" class="btn">Stop</button>
        <a id="dl" class="btn" style="display:none" download="crt.webm">Download</a>
      </div>
    </div>

    <!-- Global Hue -->
    <div class="section">
      <h3>Global Hue</h3>
      <label>Hue Rotate (°) <input id="hueRot" type="range" min="-180" max="180" step="0.1" value="0" /></label>
    </div>

    <!-- Screen Geometry -->
    <div class="section">
      <h3>Screen Geometry</h3>
      <label>Rotation (°) <input id="rot" type="range" min="-180" max="180" step="0.1" value="0" /></label>
      <label>Zoom <input id="zoom" type="range" min="0.85" max="1.5" step="0.001" value="1.0" /></label>
      <label>Aspect Ratio <input id="ratio" type="text" placeholder="4:3" /></label>
    </div>

    <!-- Phosphor & Lines -->
    <div class="section red">
      <h3>Phosphor & Lines</h3>
      <label>Scanlines <input id="scan" type="range" min="0" max="1" step="0.001" value="0.7" /></label>
      <label>Shadow Mask
        <select id="mask"><option value="0">Triad</option><option value="1">Aperture</option><option value="2">Slot</option><option value="3">Dot</option></select>
      </label>
      <label>Mask Amount <input id="maskAmt" type="range" min="0" max="1" step="0.001" value="0.65" /></label>
    </div>

    <!-- Image -->
    <div class="section">
      <h3>Image</h3>
      <label>Saturation <input id="sat" type="range" min="0" max="2" step="0.001" value="1.05" /></label>
      <label>Chromatic Ab. <input id="chroma" type="range" min="0" max="1" step="0.001" value="0.3" /></label>
      <label>Noise <input id="noise" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
      <label>Flicker <input id="flick" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
    </div>

    <!-- Mod Matrix (simplified demo routing) -->
    <div class="section green">
      <h3>Mod Matrix (per-osc target: Freq / Phase / Amp)</h3>
      <div class="row small">This demo wires modulation into Effect Scale/Speed/Amount + Synth hue. Extend as needed.</div>
      <label>Audio ➜ Effect Amount <input id="mmAudAmt" type="range" min="0" max="1" step="0.001" value="0.3" /></label>
      <label>Osc A ➜ Effect Scale <input id="mmAScale" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
      <label>Osc B ➜ Effect Speed <input id="mmBSpeed" type="range" min="0" max="1" step="0.001" value="0.2" /></label>
      <label>Osc C ➜ Synth Hue <input id="mmCHue" type="range" min="0" max="1" step="0.001" value="0.15" /></label>
    </div>

    <!-- Fullscreen -->
    <div class="section">
      <h3>Fullscreen</h3>
      <div class="row">
        <button id="btnFS" class="btn">Fullscreen (F)</button>
        <span class="small">Press L to toggle Live Cycle</span>
      </div>
    </div>

    <!-- Self-tests -->
    <div class="section">
      <h3>Self-tests</h3>
      <pre id="log">(running tests…)
</pre>
    </div>
  </aside>

  <canvas id="gl"></canvas>

<script>
(function(){
'use strict';
const $=id=>document.getElementById(id);
const C=$('gl');
let W=innerWidth-420,H=innerHeight;C.width=W;C.height=H;

const TL=$('log');const log=(s,ok)=>{TL.textContent+=(ok===undefined?'':(ok?'✔ ':'✖ '))+s+'\\n'};
const ratio=()=>{let v=($('ratio').value||'').trim();if(!v)return 0;if(v.includes(':')){const[a,b]=v.split(':').map(x=>parseFloat(x.replace(',','.')));return(isFinite(a)&&isFinite(b)&&b!==0)?a/b:0}const f=parseFloat(v.replace(',','.'));return(isFinite(f)&&f>0)?f:0};

// Sources
const SRC_CAN=document.createElement('canvas'),SRC_CTX=SRC_CAN.getContext('2d');
SRC_CAN.width=640;SRC_CAN.height=360;let bmp=null;const VID=document.createElement('video');
VID.playsInline=true;VID.muted=true;VID.loop=true;VID.preload='metadata';
let sourceMode='synth'; // 'image' | 'video' | 'pattern' | 'synth'
const pattern=(t)=>{const w=SRC_CAN.width,h=SRC_CAN.height;SRC_CTX.fillStyle='#101525';SRC_CTX.fillRect(0,0,w,h);
const bars=['#fff','#ff0','#0ff','#0f0','#f0f','#00f','#f00'];const bw=Math.floor(w/bars.length);
for(let i=0;i<bars.length;i++){SRC_CTX.fillStyle=bars[i];SRC_CTX.fillRect(i*bw,0,bw-1,Math.floor(h*0.35))}
SRC_CTX.strokeStyle='rgba(255,255,255,0.1)';for(let x=0;x<w;x+=Math.floor(w/24)){SRC_CTX.beginPath();SRC_CTX.moveTo(x,0);SRC_CTX.lineTo(x,h);SRC_CTX.stroke()}
SRC_CTX.font=Math.floor(h*0.08)+'px ui-monospace,Menlo';SRC_CTX.fillStyle='#fff';SRC_CTX.fillText('TEST PATTERN',18,h-22)};

$('btnImg').onclick=()=>$('fileImg').click();
$('btnVid').onclick=()=>$('fileVid').click();
$('btnTP').onclick=()=>{sourceMode='pattern'};
$('btnSynth').onclick=()=>{sourceMode='synth'};

$('fileImg').addEventListener('change',async e=>{
  const f=e.target.files&&e.target.files[0];if(!f) return;
  try{bmp=await createImageBitmap(f);sourceMode='image';SRC_CAN.width=bmp.width;SRC_CAN.height=bmp.height}catch(err){log('image load: '+err,false)}
});
$('fileVid').addEventListener('change',async e=>{
  const f=e.target.files&&e.target.files[0];if(!f) return;
  try{sourceMode='video';VID.src=URL.createObjectURL(f);await VID.play().catch(()=>{});$('btnPlay').textContent='Pause'}catch(err){log('video load: '+err,false)}
});

$('btnPlay').onclick=async()=>{
  if(sourceMode!=='video')return;
  if(VID.paused){await VID.play().catch(()=>{});$('btnPlay').textContent='Pause'} else {VID.pause();$('btnPlay').textContent='Play'}
};
$('btnMute').onclick=()=>{if(sourceMode!=='video')return;VID.muted=!VID.muted;$('btnMute').textContent=VID.muted?'Unmute':'Mute'};

const fmt=s=>{s=Math.max(0,s|0);const m=(s/60)|0,r=s%60;return String(m).padStart(2,'0')+':'+String(r).padStart(2,'0')};
const updTC=()=>{if(sourceMode==='video'&&isFinite(VID.duration))$('time').textContent=fmt(VID.currentTime)+' / '+fmt(VID.duration);else $('time').textContent='00:00 / 00:00'};
VID.addEventListener('timeupdate',updTC);
if('requestVideoFrameCallback'in VID){VID.requestVideoFrameCallback(function cb(){updTC();VID.requestVideoFrameCallback(cb)})}

// WebGL
const gl=C.getContext('webgl',{alpha:false,antialias:false,preserveDrawingBuffer:true});
if(!gl){TL.textContent+='WebGL not supported';return}
const VERT=`
attribute vec2 a;varying vec2 v;
void main(){v=(a+1.0)*0.5;gl_Position=vec4(a,0.,1.);}
`;
const FRAG=`
precision mediump float;varying vec2 v;
uniform vec2 u_res;uniform float u_time;
uniform sampler2D u_src;
uniform vec4 u_fx;uniform int u_maskType;uniform float u_maskAmt,u_scan,u_sat,u_ca,u_noise,u_flick,u_hue,u_rot,u_zoom,u_ratio,u_fxScale,u_fxSpeed,u_fxAmt;
uniform int u_sortHue;
mat3 hueM(float a){float U=cos(a),W=sin(a);
mat3 m=mat3(0.299,0.587,0.114,0.299,0.587,0.114,0.299,0.587,0.114);
return m+mat3(0.701,-0.587,-0.114,-0.299,0.413,-0.114,-0.3,-0.588,0.886)*U
+mat3(0.168,0.330,-0.497,-0.328,0.035,0.292,1.25,-1.05,-0.203)*W;}
float H(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float N(vec2 p){vec2 i=floor(p),f=fract(p);float a=H(i),b=H(i+vec2(1.,0.)),c=H(i+vec2(0.,1.)),d=H(i+vec2(1.,1.));vec2 u=f*f*(3.-2.*f);
return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}
float fbm(vec2 p){float n=0.,a=1.;for(int i=0;i<5;i++){n+=N(p*a)/a;a*=2.;}return n;}
vec2 crop(vec2 uv){if(u_ratio<=0.)return uv;float outR=u_res.x/u_res.y,t=u_ratio;vec2 c=uv-0.5;if(outR>t)c.x*=outR/t;else c.y*=t/outR;return c+0.5;}
vec2 rot(vec2 uv,float a){vec2 p=uv-0.5;float s=sin(a),c=cos(a);return mat2(c,-s,s,c)*p+0.5;}
vec3 maskFX(vec2 uv,int m,float k){float stripe=fract(uv.x*u_res.x/3.);vec3 tri=stripe<1./3.?vec3(1,0.7,0.7):((stripe<2./3.)?vec3(0.7,1,0.7):vec3(0.7,0.7,1));
if(m==1){float s=fract(uv.x*2.);tri=mix(vec3(1),vec3(1,1,0),step(0.5,s));}
else if(m==2){float s=fract(uv.x*2.);tri=mix(vec3(1),vec3(0.9,1,0.9),step(0.5,s));}
else if(m==3){float d=fract(uv.x*4.);tri=mix(vec3(1),vec3(1,0.9,1),step(0.25,d));}
return mix(vec3(1),tri,clamp(k,0.,1.));}
vec3 plasma(vec2 uv){return 0.5+0.5*cos(u_time+uv.xyx*vec3(1,1.3,1.7));}
vec3 voro(vec2 uv){vec2 g=floor(uv),f=fract(uv);float md=1.;for(int y=-1;y<=1;y++)for(int x=-1;x<=1;x++){vec2 o=vec2(float(x),float(y));vec2 rp=g+o+H(g+o);float d=length(f-o-rp);md=min(md,d);}return vec3(md);}
float lum(vec3 c){return dot(c,vec3(0.2126,0.7152,0.0722));}
vec3 psamp(vec2 uv){float stepPx=1.0/u_res.x;vec3 a=texture2D(u_src,uv).rgb;vec3 b=texture2D(u_src,uv+vec2(stepPx,0.)).rgb;
float la=u_sortHue==1?atan(a.g*1.732,a.b-a.r):lum(a);
float lb=u_sortHue==1?atan(b.g*1.732,b.b-b.r):lum(b);
return la<lb?a:b;}
void main(){
  vec2 uv=crop(v); uv=rot(uv,radians(u_rot)); uv=(uv-0.5)/u_zoom+0.5;
  if(any(lessThan(uv,vec2(0.)))||any(greaterThan(uv,vec2(1.)))){gl_FragColor=vec4(0,0,0,1);return;}
  vec3 col=texture2D(u_src,uv).rgb;
  if(u_fx.x>0.5){float f=fbm(uv*u_fxScale+u_time*u_fxSpeed);col=mix(col,vec3(f),u_fxAmt);}
  if(u_fx.y>0.5){vec3 p=plasma(uv*u_fxScale);col=mix(col,p,u_fxAmt);}
  if(u_fx.z>0.5){vec3 v=voro(uv*u_fxScale);col=mix(col,v,u_fxAmt);}
  if(u_fx.w>0.5){vec3 s=psamp(uv);col=mix(col,s,u_fxAmt);}
  vec2 dir=(uv-0.5);float ca=u_ca*0.004;vec2 off=ca*normalize(dir+1e-5);
  vec3 caCol=vec3(texture2D(u_src,uv+off).r,col.g,texture2D(u_src,uv-off).b);
  col=mix(col,caCol,clamp(u_ca,0.,1.));
  float sc=sin(uv.y*u_res.y*3.14159);col*=mix(1.,0.6+0.4*sc,u_scan);
  col*=maskFX(uv,u_maskType,u_maskAmt);
  float L=lum(col);col=mix(vec3(L),col,clamp(u_sat,0.,2.));
  float n=H(floor(uv*u_res)+u_time);col*=1.+(u_flick*(sin(u_time*120.)*.03));
  col+=(n-.5)*.12*u_noise;
  col=clamp(hueM(radians(u_hue))*col,0.,1.);
  gl_FragColor=vec4(col,1.);
}
`;
function sh(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);return s}
const prog=gl.createProgram();gl.attachShader(prog,sh(gl.VERTEX_SHADER,VERT));gl.attachShader(prog,sh(gl.FRAGMENT_SHADER,FRAG));gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS))throw gl.getProgramInfoLog(prog);gl.useProgram(prog);
const vbo=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vbo);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
const a=gl.getAttribLocation(prog,'a');gl.enableVertexAttribArray(a);gl.vertexAttribPointer(a,2,gl.FLOAT,false,0,0);
const U=n=>gl.getUniformLocation(prog,n),u={
  res:U('u_res'),time:U('u_time'),src:U('u_src'),fx:U('u_fx'),maskType:U('u_maskType'),
  maskAmt:U('u_maskAmt'),scan:U('u_scan'),sat:U('u_sat'),ca:U('u_ca'),noise:U('u_noise'),flick:U('u_flick'),
  hue:U('u_hue'),rot:U('u_rot'),zoom:U('u_zoom'),ratio:U('u_ratio'),fxScale:U('u_fxScale'),
  fxSpeed:U('u_fxSpeed'),fxAmt:U('u_fxAmt'),sortHue:U('u_sortHue')
};
const tex=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,tex);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
gl.uniform1i(u.src,0);

// Presets (quick)
const applyPreset = (name)=>{
  const set=(id,val)=>{$(id).value=val};
  const on=(id,val)=>{$(id).checked=!!val};
  if(name==='Minimal CRT'){on('fxFractal',0);on('fxPlasma',0);on('fxVoro',0);on('fxSort',0);set('scan',0.6);set('mask','0');set('maskAmt',0.5);set('sat',1.0);set('chroma',0.15);set('noise',0.1);set('flick',0.1)}
  if(name==='Liquid Plasma'){on('fxPlasma',1);on('fxFractal',0);on('fxVoro',0);on('fxSort',0);set('fxScale',3);set('fxSpeed',1.2);set('fxAmt',0.9);set('mask','1');set('maskAmt',0.7)}
  if(name==='Cellular Drift'){on('fxPlasma',0);on('fxFractal',0);on('fxVoro',1);on('fxSort',0);set('fxScale',6);set('fxSpeed',0.6);set('fxAmt',1.0);set('scan',0.75)}
  if(name==='Pixel Glow'){on('fxSort',1);set('sortMode','lum');set('fxAmt',0.8);set('mask','2');set('maskAmt',0.65)}
  if(name==='Retro Arcade'){set('mask','0');set('sat',1.3);set('scan',0.85);set('noise',0.15)}
  if(name==='Calm Geometry'){on('fxPlasma',1);set('fxAmt',0.3);set('scan',0.4);set('sat',0.9)}
  if(name==='Ghost Trails'){set('noise',0.35);set('flick',0.25);set('sat',0.9)}
};
$('btnLoad').onclick=()=>{const p=$('preset').value;if(p)applyPreset(p)};
$('btnRand').onclick=()=>{['fxFractal','fxPlasma','fxVoro','fxSort'].forEach(id=>$(id).checked=Math.random()<.5);['fxScale','fxSpeed','fxAmt','maskAmt','scan','sat','chroma','noise','flick'].forEach(id=>$(id).value=(Math.random()*parseFloat($(id).max||1)).toFixed(2))};

// Live Cycle
let liveLast=0;const liveStateKey='liveCycleState';
(()=>{try{const s=JSON.parse(localStorage.getItem(liveStateKey)||'{}');if(s.enabled){$('live').checked=true;$('liveSecs').value=s.secs||20;$('liveBlend').value=s.blend||'cut'}}catch{}})();
const saveLive=()=>{try{localStorage.setItem(liveStateKey,JSON.stringify({enabled:$('live').checked,secs:parseFloat($('liveSecs').value||20),blend:$('liveBlend').value}))}catch{}};

// Fullscreen (policy safe)
function tryNativeFS(){return new Promise((res,rej)=>{const el=C;const req=el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen;if(!req) return rej('No Fullscreen API');try{const p=req.call(el);if(p&&p.then)p.then(()=>res('ok')).catch(rej);else res('ok')}catch(e){rej(e)}})}
$('btnFS').onclick=()=>{if(!document.fullscreenElement){tryNativeFS().catch(()=>{document.body.classList.add('pf')})}else{(document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen)?.call(document);document.body.classList.remove('pf')}};
document.addEventListener('keydown',e=>{if(e.key==='f'||e.key==='F')$('btnFS').click(); if(e.key==='l'||e.key==='L'){$('live').checked=!$('live').checked;saveLive();}});

// Audio (guarded)
let micStream=null,analyser=null,afBuf=null;
$('btnMic').onclick=async()=>{try{micStream=await navigator.mediaDevices.getUserMedia({audio:true});const actx=new (window.AudioContext||window.webkitAudioContext)();const src=actx.createMediaStreamSource(micStream);analyser=actx.createAnalyser();analyser.fftSize=512;src.connect(analyser);afBuf=new Uint8Array(analyser.frequencyBinCount)}catch(e){log('Mic blocked by permissions policy',false)}};
function audioBands(){if(!analyser){$('vL').textContent='0';$('vM').textContent='0';$('vH').textContent='0';return {l:0,m:0,h:0}}analyser.getByteFrequencyData(afBuf);const n=afBuf.length;let l=0,m=0,h=0;for(let i=0;i<n;i++){const v=afBuf[i]/255;if(i<n/3)l+=v;else if(i<2*n/3)m+=v;else h+=v}l/=n/3;m/=n/3;h/=n/3;$('vL').textContent=l.toFixed(2);$('vM').textContent=m.toFixed(2);$('vH').textContent=h.toFixed(2);return {l,m,h}}

// Tests
(function(){
  const ids=['btnImg','btnVid','btnTP','btnSynth','preset','btnLoad','btnRand','btnSnap','audSrc','btnMic','fxFractal','fxPlasma','fxVoro','fxSort','sortMode','fracType','fxScale','fxSpeed','fxAmt','fbAmt','fbBlur','fbDrift','fbTaps','fbDecay','hueRot','rot','zoom','ratio','scan','mask','maskAmt','sat','chroma','noise','flick','btnFS'];
  log('UI elements present: '+ids.every(id=>!!$(id)));
  const rEl=$('ratio');const cases=[["4:3",4/3],["16:9",16/9],["1.25",1.25],["1,25",1.25],[" 21 : 9 ",21/9],["9:16",9/16]];
  let ok=true;for(const[i,e]of cases){rEl.value=i;const v=ratio();const p=Math.abs(v-e)<1e-6;ok=ok&&p;log(`ratio("${i}") == ${e.toFixed(6)}`,p)}rEl.value='';
  log('Self-tests done',ok);
})();

// Frame update of source texture
function updateSource(t){
  if(sourceMode==='pattern'){pattern(t)}
  else if(sourceMode==='image'&&bmp){if(SRC_CAN.width!==bmp.width||SRC_CAN.height!==bmp.height){SRC_CAN.width=bmp.width;SRC_CAN.height=bmp.height}SRC_CTX.drawImage(bmp,0,0,SRC_CAN.width,SRC_CAN.height)}
  else if(sourceMode==='video'&&VID.readyState>=2){const vw=VID.videoWidth||640,vh=VID.videoHeight||360;if(SRC_CAN.width!==vw||SRC_CAN.height!==vh){SRC_CAN.width=vw;SRC_CAN.height=vh}SRC_CTX.drawImage(VID,0,0,SRC_CAN.width,SRC_CAN.height)}
  gl.activeTexture(gl.TEXTURE0);gl.bindTexture(gl.TEXTURE_2D,tex);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,SRC_CAN);
}

// Render loop
function frame(ts){
  const t=ts*0.001;
  if($('live').checked){const secs=parseFloat($('liveSecs').value||20);if(ts-liveLast>secs*1000){liveLast=ts;saveLive();if($('liveBlend').value==='cut') $('btnRand').click(); else { // simple blend target: nudge major params
      const n=()=>Math.random();
      $('fxAmt').value=(parseFloat($('fxAmt').value)*0.3+0.7*n()).toFixed(3);
      $('fxScale').value=(parseFloat($('fxScale').value)*0.6+0.4*(1+11*n())).toFixed(3);
      $('fxSpeed').value=(parseFloat($('fxSpeed').value)*0.6+0.4*(4*n())).toFixed(3);
      $('scan').value=(parseFloat($('scan').value)*0.5+0.5*n()).toFixed(3);
      $('sat').value=(parseFloat($('sat').value)*0.5+0.5*(2*n())).toFixed(3);
    }}}
  updateSource(t);
  const {l:audL,m:audM,h:audH}=audioBands();

  gl.viewport(0,0,C.width,C.height);
  gl.uniform2f(u.res,C.width,C.height);
  gl.uniform1f(u.time,t);

  // Effect bitflags → vec4 (WebGL1 safe)
  const fx=[ $('fxFractal').checked?1:0, $('fxPlasma').checked?1:0, $('fxVoro').checked?1:0, $('fxSort').checked?1:0 ];
  gl.uniform4f(u.fx,fx[0],fx[1],fx[2],fx[3]);

  const sortHue = $('sortMode').value==='hue' ? 1 : 0;
  gl.uniform1i(u.sortHue,sortHue);

  // Mod matrix demo routing
  const mmAmt=parseFloat($('mmAudAmt').value||0); // audio → fxAmt
  const mmSc =parseFloat($('mmAScale').value||0); // A → scale
  const mmSp =parseFloat($('mmBSpeed').value||0); // B → speed
  const mmHue=parseFloat($('mmCHue').value||0);   // C → hue

  const fxScale = parseFloat($('fxScale').value||3) * (1.0 + mmSc*Math.sin(t*2.0));
  const fxSpeed = parseFloat($('fxSpeed').value||1) * (1.0 + mmSp*Math.sin(t*1.5));
  const fxAmt   = Math.min(1, Math.max(0, parseFloat($('fxAmt').value||1) + mmAmt*audM*0.5));

  gl.uniform1f(u.fxScale,fxScale);
  gl.uniform1f(u.fxSpeed,fxSpeed);
  gl.uniform1f(u.fxAmt,fxAmt);

  gl.uniform1i(u.maskType,parseInt($('mask').value||'0'));
  gl.uniform1f(u.maskAmt,parseFloat($('maskAmt').value||0.65));
  gl.uniform1f(u.scan,parseFloat($('scan').value||0.7));
  gl.uniform1f(u.sat,parseFloat($('sat').value||1.0));
  gl.uniform1f(u.ca,parseFloat($('chroma').value||0.15));
  gl.uniform1f(u.noise,parseFloat($('noise').value||0.2));
  gl.uniform1f(u.flick,parseFloat($('flick').value||0.2));
  gl.uniform1f(u.hue,parseFloat($('hueRot').value||0) + mmHue*60.0*Math.sin(t*0.7));
  gl.uniform1f(u.rot,parseFloat($('rot').value||0));
  gl.uniform1f(u.zoom,parseFloat($('zoom').value||1.0));
  gl.uniform1f(u.ratio,ratio());

  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// Resize
addEventListener('resize',()=>{W=innerWidth-420;H=innerHeight;C.width=W;C.height=H});

// Recording (policy-safe message)
$('btnRec').onclick=()=>log('Recording disabled in sandbox by permissions policy (MediaRecorder / capture).',false);
$('btnStop').onclick=()=>{};
$('dl').style.display='none';

})();
</script>
</body>
</html>
